
- Basic idea
- Why?
    - Everything in one place / folder / "repository"
        - portability
        - replication
        - never share a project that can't run
    - History of the project
        - transparency
        - restore broken code to some older (working) state
        - track what you/others did
        - "why did the results change?"
    - collaboration
        - "track changes" for many team members
        - combine parallel development branches
- Lay of the land:
    - project folder == "repository"
    - source code
    - documentation
    - output
    - intermediary files
- Local terminology:
    - init
    - working directory
    - add/staging (the INDEX)
    - commit
- Git only saves data about _changes_
    - keeps it lightweight
    - remembers everything that happened in order
    - sometimes mistakes get preserved
- What (not) to commit
    - ignoring
    - debate: <https://twitter.com/JennyBryan/status/1114924383946960896>
    - log file
    - <https://dvc.org/>
- Remotes
    - local repository
    - remote repository
    - online backup
    - "production code" v "development code"
- Remote terminology
    - Github account
    - Github pro
    - after commit: git push
    - git pull
- Tips
    - informative, verbs
    - don't commit big files (we'll talk about this soon)
    - push often
- When things go wrong
    - Always research before trying something new
    - go slowly
    - stash changes
    - google is your friend
    - oh shit git
    - re-download from remote!
    - nuclear option
- Things for me to learn
    - revert vs reset <https://dev.to/neshaz/when-to-use-git-reset-git-revert--git-checkout-18je>, <https://gist.github.com/tnguyen14/0827ae6eefdff39e452b>
    - checkout (in same branch?)
    - branch vs node vs HEAD vs index vs working directory...
    - merge vs rebase



Next week:

- Add GitHub to SourceTree (use HTTPS?)
- Make a project
    - init
    - add
    - commit
- Local and remote
    - define
    - Create GH repo
    - push
    - if no work, push from the command line
        - terminal
        - cd
        - git status
- Data
    - explain the problem
        - small data? Commit
        - large data? LFS
    - Doing LFS
        - Install LFS
        - use sourcetree to add things to LFS
        - add .gitattributes
        - add file as normal, push
        - Github says file is tracked with LFS
    - Or, you could store data somewhere else and import w/ code
- Branches
    - good for testing out experimental features and then merging back in
    - if you hit a conflict, how to read it
    - sometimes you want to jump to a branch without committing: STASH your changes, and then "apply" or "pop" the stash later.
- Dealing with risks:
    - Copy the repo, test what you're doing on the copy
    - push BEFORE you do something risky, so the remote version works the way you want. 
- History Hacking
- Reset
- Terminology
    - HEAD: which commit we're "pointing" to
- what to do about data:
    - if your data are smallish, you can commit.
    - git LFS (pointer to data, not the data itself)
        - size limitations
    - save data somewhere else
        - read in using some different script
        - I use Box sometimes
        - other people use Amazon s3


